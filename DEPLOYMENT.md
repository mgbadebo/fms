# Farm Management System - Production Deployment Guide

This guide covers the steps to deploy the FMS backend API as a production-ready application for real farm use.

## Table of Contents

1. [Pre-Deployment Checklist](#pre-deployment-checklist)
2. [Server Setup](#server-setup)
3. [Application Deployment](#application-deployment)
4. [Database Configuration](#database-configuration)
5. [Security Hardening](#security-hardening)
6. [Frontend Integration](#frontend-integration)
7. [Monitoring & Maintenance](#monitoring--maintenance)
8. [Scaling Considerations](#scaling-considerations)

---

## Pre-Deployment Checklist

### 1. Code Review & Testing
- [ ] Run all tests: `php artisan test`
- [ ] Review and fix any linter errors
- [ ] Test all critical API endpoints
- [ ] Verify scale and label printing integrations work
- [ ] Test authentication and authorization flows

### 2. Environment Configuration
- [ ] Set `APP_ENV=production` in `.env`
- [ ] Set `APP_DEBUG=false` in `.env`
- [ ] Generate new `APP_KEY` for production
- [ ] Configure production database credentials
- [ ] Set up Redis/cache for production
- [ ] Configure queue workers (if using queues)

### 3. Security Review
- [ ] Review all API endpoints for proper authorization
- [ ] Ensure CORS is properly configured
- [ ] Set up rate limiting
- [ ] Review and update default passwords
- [ ] Enable HTTPS/SSL certificates

---

## Server Setup

### Option A: Traditional VPS (DigitalOcean, Linode, AWS EC2)

#### 1. Server Requirements
- **Minimum**: 2 CPU cores, 4GB RAM, 20GB storage
- **Recommended**: 4 CPU cores, 8GB RAM, 50GB storage
- **OS**: Ubuntu 22.04 LTS or similar

#### 2. Install Required Software

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install PHP 8.2+ and extensions
sudo apt install -y php8.2 php8.2-fpm php8.2-cli php8.2-mysql php8.2-xml \
    php8.2-mbstring php8.2-curl php8.2-zip php8.2-gd php8.2-bcmath

# Install Composer
curl -sS https://getcomposer.org/installer | php
sudo mv composer.phar /usr/local/bin/composer

# Install MySQL/PostgreSQL
sudo apt install -y mysql-server  # or postgresql

# Install Nginx
sudo apt install -y nginx

# Install Node.js (for frontend builds if needed)
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs

# Install Redis (for caching/queues)
sudo apt install -y redis-server
```

#### 3. Create Application User

```bash
sudo adduser --disabled-password --gecos "" fms
sudo usermod -aG www-data fms
```

### Option B: Cloud Platform (Laravel Forge, Ploi, AWS Elastic Beanstalk)

These platforms automate much of the server setup:
- **Laravel Forge**: https://forge.laravel.com
- **Ploi**: https://ploi.io
- **AWS Elastic Beanstalk**: With Laravel configuration

---

## Application Deployment

### 1. Clone and Setup Application

```bash
# Switch to application user
sudo su - fms

# Clone repository (or upload files)
git clone <your-repo-url> /home/fms/fms
cd /home/fms/fms

# Install dependencies
composer install --optimize-autoloader --no-dev

# Copy environment file
cp .env.example .env

# Generate application key
php artisan key:generate
```

### 2. Configure Environment Variables

Edit `/home/fms/fms/.env`:

```env
APP_NAME="Farm Management System"
APP_ENV=production
APP_KEY=base64:... # Generated by artisan key:generate
APP_DEBUG=false
APP_URL=https://yourdomain.com

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=error

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=fms_production
DB_USERNAME=fms_user
DB_PASSWORD=secure_password_here

BROADCAST_DRIVER=log
CACHE_DRIVER=redis
FILESYSTEM_DISK=local
QUEUE_CONNECTION=redis
SESSION_DRIVER=redis
SESSION_LIFETIME=120

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

# Sanctum configuration
SANCTUM_STATEFUL_DOMAINS=yourdomain.com,www.yourdomain.com
SESSION_DOMAIN=.yourdomain.com

# Mail configuration (for notifications)
MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="noreply@yourdomain.com"
MAIL_FROM_NAME="${APP_NAME}"
```

### 3. Run Migrations and Seeders

```bash
# Run migrations
php artisan migrate --force

# Seed initial data (roles, admin user, etc.)
php artisan db:seed --class=DatabaseSeeder

# Create storage link
php artisan storage:link

# Cache configuration for performance
php artisan config:cache
php artisan route:cache
php artisan view:cache
```

### 4. Set Permissions

```bash
sudo chown -R fms:www-data /home/fms/fms
sudo chmod -R 755 /home/fms/fms
sudo chmod -R 775 /home/fms/fms/storage
sudo chmod -R 775 /home/fms/fms/bootstrap/cache
```

---

## Database Configuration

### 1. Create Production Database

```bash
sudo mysql -u root -p
```

```sql
CREATE DATABASE fms_production CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'fms_user'@'localhost' IDENTIFIED BY 'secure_password_here';
GRANT ALL PRIVILEGES ON fms_production.* TO 'fms_user'@'localhost';
FLUSH PRIVILEGES;
EXIT;
```

### 2. Backup Strategy

Set up automated backups:

```bash
# Create backup script
sudo nano /home/fms/backup-db.sh
```

```bash
#!/bin/bash
BACKUP_DIR="/home/fms/backups"
DATE=$(date +%Y%m%d_%H%M%S)
mkdir -p $BACKUP_DIR

# Database backup
mysqldump -u fms_user -p'password' fms_production > $BACKUP_DIR/db_$DATE.sql

# Keep only last 30 days
find $BACKUP_DIR -name "db_*.sql" -mtime +30 -delete
```

```bash
chmod +x /home/fms/backup-db.sh

# Add to crontab (daily at 2 AM)
crontab -e
# Add: 0 2 * * * /home/fms/backup-db.sh
```

---

## Security Hardening

### 1. Nginx Configuration

Create `/etc/nginx/sites-available/fms`:

```nginx
server {
    listen 80;
    server_name yourdomain.com www.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name yourdomain.com www.yourdomain.com;
    root /home/fms/fms/public;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-Content-Type-Options "nosniff";
    add_header X-XSS-Protection "1; mode=block";

    index index.php;

    charset utf-8;

    # SSL Configuration (use Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }

    error_page 404 /index.php;

    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\.(?!well-known).* {
        deny all;
    }
}
```

```bash
sudo ln -s /etc/nginx/sites-available/fms /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

### 2. SSL Certificate (Let's Encrypt)

```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com
# Auto-renewal is set up automatically
```

### 3. Firewall Configuration

```bash
sudo ufw allow 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

### 4. Rate Limiting

Add to `app/Http/Kernel.php` or `bootstrap/app.php`:

```php
// In API routes
Route::middleware(['auth:sanctum', 'throttle:60,1'])->group(function () {
    // Your API routes
});
```

### 5. Update Default Credentials

```bash
php artisan tinker
```

```php
$admin = User::where('email', 'admin@fms.test')->first();
$admin->password = Hash::make('new_secure_password');
$admin->save();
```

---

## Frontend Integration

### Option A: Single Page Application (SPA)

#### Recommended Frameworks:
- **Vue.js 3** with Vite
- **React** with Vite
- **Angular**

#### Setup Steps:

1. **Create Frontend Project** (example with Vue.js):

```bash
npm create vue@latest fms-frontend
cd fms-frontend
npm install
npm install axios
```

2. **Configure API Base URL**:

Create `src/config/api.js`:
```javascript
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://yourdomain.com/api/v1',
  headers: {
    'Content-Type': 'application/json',
  }
});

// Add token to requests
api.interceptors.request.use(config => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;
```

3. **Build and Deploy**:

```bash
npm run build
# Deploy dist/ folder to CDN or static hosting
```

#### Deployment Options:
- **Vercel**: https://vercel.com
- **Netlify**: https://netlify.com
- **AWS S3 + CloudFront**
- **Same server** (serve from Nginx)

### Option B: Mobile Application

#### Recommended Frameworks:
- **React Native**
- **Flutter**
- **Ionic**

#### API Integration:
- Use the same API endpoints
- Store tokens securely (Keychain/Keystore)
- Handle offline scenarios

### Option C: Progressive Web App (PWA)

Convert the SPA to a PWA for mobile-like experience:
- Add service worker
- Add manifest.json
- Enable offline capabilities

---

## Monitoring & Maintenance

### 1. Application Monitoring

#### Laravel Telescope (Development/Staging)
```bash
composer require laravel/telescope --dev
php artisan telescope:install
php artisan migrate
```

#### Production Monitoring Options:
- **Laravel Pulse**: Built-in monitoring
- **Sentry**: Error tracking
- **New Relic**: APM
- **Datadog**: Full-stack monitoring

### 2. Log Management

```bash
# Configure log rotation
sudo nano /etc/logrotate.d/fms
```

```
/home/fms/fms/storage/logs/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 fms www-data
    sharedscripts
}
```

### 3. Queue Workers

If using queues for background jobs:

```bash
# Create systemd service
sudo nano /etc/systemd/system/fms-worker.service
```

```ini
[Unit]
Description=FMS Queue Worker
After=network.target

[Service]
User=fms
Group=www-data
Restart=always
ExecStart=/usr/bin/php /home/fms/fms/artisan queue:work redis --sleep=3 --tries=3 --max-time=3600

[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl enable fms-worker
sudo systemctl start fms-worker
```

### 4. Scheduled Tasks

```bash
# Add to crontab
crontab -e
```

```
* * * * * cd /home/fms/fms && php artisan schedule:run >> /dev/null 2>&1
```

### 5. Health Checks

Create a health check endpoint in `routes/web.php`:

```php
Route::get('/health', function () {
    return response()->json([
        'status' => 'healthy',
        'database' => DB::connection()->getPdo() ? 'connected' : 'disconnected',
        'cache' => Cache::get('health_check') === 'ok' ? 'working' : 'not_working',
    ]);
});
```

---

## Scaling Considerations

### 1. Database Optimization

- Add indexes on frequently queried columns
- Use database read replicas for read-heavy operations
- Implement query caching
- Use connection pooling

### 2. Caching Strategy

```php
// Cache frequently accessed data
Cache::remember('farms_list', 3600, function () {
    return Farm::all();
});
```

### 3. Load Balancing

- Use multiple application servers
- Set up Nginx as load balancer
- Use Redis for shared session storage
- Implement database replication

### 4. CDN for Static Assets

- Serve static files through CDN (CloudFlare, AWS CloudFront)
- Cache API responses where appropriate

### 5. Horizontal Scaling

- Use containerization (Docker)
- Deploy with Kubernetes (for large scale)
- Use managed services (AWS ECS, Google Cloud Run)

---

## Deployment Checklist

### Initial Deployment
- [ ] Server provisioned and secured
- [ ] Application code deployed
- [ ] Database created and migrated
- [ ] Environment variables configured
- [ ] SSL certificate installed
- [ ] Nginx configured and tested
- [ ] Firewall rules set
- [ ] Backup system configured
- [ ] Monitoring set up
- [ ] Queue workers running
- [ ] Scheduled tasks configured

### Post-Deployment
- [ ] Test all critical API endpoints
- [ ] Verify authentication works
- [ ] Test scale integration (if hardware available)
- [ ] Test label printing (if printer available)
- [ ] Create initial admin user
- [ ] Set up user onboarding process
- [ ] Document farm-specific configurations
- [ ] Train farm staff on API usage

### Ongoing Maintenance
- [ ] Regular security updates
- [ ] Database backups verified
- [ ] Monitor application performance
- [ ] Review and rotate API tokens
- [ ] Update dependencies regularly
- [ ] Review access logs
- [ ] Plan for capacity scaling

---

## Quick Deployment Script

Create `deploy.sh` for automated deployments:

```bash
#!/bin/bash
set -e

echo "ðŸš€ Starting deployment..."

cd /home/fms/fms

# Pull latest code
git pull origin main

# Install dependencies
composer install --no-dev --optimize-autoloader

# Run migrations
php artisan migrate --force

# Clear and cache
php artisan config:cache
php artisan route:cache
php artisan view:cache

# Restart services
sudo systemctl restart php8.2-fpm
sudo systemctl restart fms-worker

echo "âœ… Deployment complete!"
```

---

## Support & Documentation

- **API Documentation**: Consider using Laravel API Documentation tools:
  - Laravel API Documentation Generator
  - Scribe
  - Swagger/OpenAPI

- **User Training**: Create user guides for:
  - Farm administrators
  - Field workers
  - Finance team

---

## Next Steps After Deployment

1. **Create Farm-Specific Configuration**
   - Set up initial farms
   - Configure seasons
   - Add master data (crops, breeds, etc.)

2. **Integrate Hardware**
   - Connect real scale devices
   - Set up label printers
   - Configure IoT sensors

3. **User Onboarding**
   - Create user accounts
   - Assign roles and permissions
   - Train users on API usage

4. **Frontend Development**
   - Build or integrate frontend application
   - Mobile app development
   - Dashboard and reporting

5. **Customization**
   - Farm-specific workflows
   - Custom reports
   - Integration with other systems

---

## Emergency Procedures

### Rollback Plan
```bash
cd /home/fms/fms
git checkout <previous-commit>
composer install
php artisan migrate:rollback --step=1
php artisan config:cache
sudo systemctl restart php8.2-fpm
```

### Database Recovery
```bash
mysql -u fms_user -p fms_production < /home/fms/backups/db_YYYYMMDD_HHMMSS.sql
```

---

This deployment guide provides a comprehensive path from development to production. Adjust based on your specific infrastructure and requirements.

